# 받을 수 있는 가장 높은 점수 : 60점
# 불 + 싱글의 가장 높은 점수 : 70점
# 300점이면 60 * 5, 50 * 6이 분기점이다.
# 299점이면 60 * 4 + 50 + 9
# 140점이면 불 싱글 불 싱글 , 60 60 20
# 119 = 60 + 50 + 9
# N점 이상일 때는 60점을 빼야한다는걸 알아야한다? N은 몇일까 ?
# 69점 인듯?
# 60점씩 빼다가 51 ~ 70점이면 불 + 싱글
# 
# dp를 사용해야하나 ?

def solution(target):
    n = max(61, target + 1)
    
    # d[i] : [i 점수를 맞출 때 맞춘 최소 다트 수, 싱글 또는 불의 개수]
    d = [[target, 0] for _ in range(n)]  # 최대값으로 초기화
    
    # 불 맞출 경우 (50점은 무조건 1번에 가능하고, 불은 싱글로 취급)
    d[50] = [1, 1] 

    # 1부터 20까지의 점수에 대해 싱글, 더블, 트리플 값을 설정
    for i in range(1, 21):
        d[i] = [1, 1]  # 싱글은 무조건 다트 1개에 싱글 1개
        d[i*2] = [1, 0]  # 더블은 1개의 다트지만 싱글 아님
        d[i*3] = [1, 0]  # 트리플도 1개의 다트지만 싱글 아님
    
    # target을 맞추기 위해 각 점수를 순차적으로 탐색
    for i in range(21, target + 1):
        single = []  # 싱글 또는 불 개수를 고려한 여러 경우를 담을 리스트
        
        # 각 다트 점수 조합을 탐색
        for j in range(1, 61):  # 1 ~ 60점 (싱글, 더블, 트리플 + 불)
            if i - j >= 0 and d[i - j][0] + d[j][0] <= d[i][0]:
                # 최소 다트 수로 갱신
                d[i][0] = d[i - j][0] + d[j][0]
                # 싱글 또는 불 개수를 기록
                single.append([d[i - j][0] + d[j][0], d[i - j][1] + d[j][1]])
        
        # 다트 수가 같을 때 싱글/불 개수가 많은 경우를 우선 선택
        single.sort(key=lambda x: [x[0], -x[1]])
        
        if single:
            d[i] = single[0]

    return d[target]
