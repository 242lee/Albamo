# f(x) = f(x - 1)의 3번 반복, f(x - 1)의 1번과 빈칸 f(x - 1) 1번, f(x - 1)의 3번 반복.
# 이걸 2차원 배열로 하려고 하면 테트리스가 아니므로 구현 힘들 것 같음.

# 그럼 어떻게 ?
# f(x)면 f(x/3)에 해당하는 것을 첫번째 줄처럼 코딩해서 재귀 진행.

# 재귀를 진행하려면 몇 가지 생각을 해야한다.
# 1. 베이스 조건, 즉 재귀를 멈추는 조건이 필요하다.
# 2. 분해, 재귀 호출을 거듭하면서 베이스 조건에 가까워지게 인풋값을 조작해야한다.
# 3. 조합, 부분 답을 가지고 전체 답을 구하는 방법을 생각해본다.

# 베이스 조건 => n == 1 일때
# 분해 => n이 3의 제곱수로 주어지기 때문에 n//3에 해당하는 인풋값을 넣어서 재귀 호출.
# 조합 => n이 3이라고 생각해보자. 맨 위에서 설명한 대로 f(x - 1)의 값을 반복해서 호출해야 한다.
#         f(3)일 때는 f(1)의 값을 반복해서 호출해야 하는데 f(1)은 가장 작은 *을 리턴해줘야 f(3)의 값이 저장 된다
#         형식은 list : ['***', '* *', '***'] 와 같이 호출될 것이다.
# f(27)을 생각해보면 list : [f(9) * 3, f(9) + ' ' * 9 + f(9), f(9) * 3]
#                          [(f(3) * 3, f(3) + ' '*3 + f(3), f(3) * 3) * 3, ... ]
#                          [((f(1) * 3, f(1) + ' '*1 + f(1), f(1)) * 3, ... ) * 3]


def StarMap(n):
  if n == 1:
    return ['*']

  Stars = StarMap(n//3)
  list = []

  for star in Stars:
    list.append(star*3)
  for star in Stars:
    list.append(star+' '*(n//3)+star)
  for star in Stars:
    list.append(star*3)

  return list

N = int(input())

print('\n'.join(StarMap(N)))