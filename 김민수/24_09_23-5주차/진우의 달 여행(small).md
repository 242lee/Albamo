아래는 백준 17484번 "진우의 달 여행 (Small)" 문제를 해결하는 파이썬 코드에 대한 `README.md` 작성 예시입니다. 문제 해결 전략과 코드의 주요 부분에 대한 설명을 포함하여 작성하였습니다.

---

## 진우의 달 여행 (백준 17484번) - Python 풀이

### 문제 설명
진우는 달에서 여행을 하면서 우주선을 이동시켜야 합니다. 매 행(row)마다 좌, 중앙, 우 중 한 방향으로만 이동할 수 있으며, **연속해서 같은 방향으로 이동할 수 없습니다**. 각 위치에는 비용이 있으며, 이 비용은 해당 위치에 도착하기 위해 사용한 연료의 양을 의미합니다.

목표는 첫 번째 행에서 출발하여 마지막 행에 도착할 때까지의 **최소 연료 비용**을 구하는 것입니다.

### 해결 방법 (Dynamic Programming)
이 문제는 동적 계획법(DP)을 사용하여 효율적으로 해결할 수 있습니다. 각 셀로 이동할 때의 최소 비용을 계산하고, 이를 활용하여 최종적으로 마지막 행에서 최소 비용을 구하는 방식입니다.

#### 주요 해결 전략:
1. **3차원 DP 배열**을 사용합니다. 각 위치 `(i, j)`로 이동할 때, 이전 행에서 어떤 방향(좌, 중앙, 우)에서 이동해왔는지에 따라 최소 비용을 저장합니다.
2. **제약 조건**: 같은 방향으로 연속해서 이동할 수 없으므로, 각 행에 대해 이전 행의 세 가지 방향(좌, 중앙, 우) 중 최소 비용을 선택하여 이동합니다.
3. **DP 배열 초기화**: 첫 번째 행에서는 각 셀의 비용을 그대로 초기화합니다. 이후 각 행에서 이전 행의 값을 참고하여 최소 비용을 갱신해 나갑니다.

### 코드 설명

```python
import sys
input = sys.stdin.readline

def solve():
    n, m = map(int, input().split())
    planet = [list(map(int, input().split())) for _ in range(n)]

    # dp[i][j][k]: i행 j열에 k방향(0: 좌, 1: 중앙, 2: 우)으로 도착했을 때의 최소 비용
    dp = [[[float('inf')] * 3 for _ in range(m)] for _ in range(n)]

    # 첫 번째 행의 비용을 초기화
    for j in range(m):
        for k in range(3):
            dp[0][j][k] = planet[0][j]

    # 두 번째 행부터 마지막 행까지 최소 비용 계산
    for i in range(1, n):
        for j in range(m):
            # 왼쪽에서 오는 경우
            if j > 0:
                dp[i][j][0] = min(dp[i][j][0], dp[i-1][j-1][1], dp[i-1][j-1][2]) + planet[i][j]
            # 중앙에서 오는 경우
            dp[i][j][1] = min(dp[i][j][1], dp[i-1][j][0], dp[i-1][j][2]) + planet[i][j]
            # 오른쪽에서 오는 경우
            if j < m - 1:
                dp[i][j][2] = min(dp[i][j][2], dp[i-1][j+1][0], dp[i-1][j+1][1]) + planet[i][j]

    # 마지막 행에서 최소값 추출
    result = float('inf')
    for j in range(m):
        result = min(result, dp[n-1][j][0], dp[n-1][j][1], dp[n-1][j][2])

    print(result)

solve()
```

### DP 배열 설명

#### `dp[i][j][k]`의 의미:
- `i`: 현재 탐색 중인 **행 번호**.
- `j`: 현재 탐색 중인 **열 번호**.
- `k`: **이전 행**에서 현재 위치로 이동할 때의 **방향**.
  - `k = 0`: 이전 열의 왼쪽에서 이동한 경우.
  - `k = 1`: 이전 열의 중앙에서 이동한 경우.
  - `k = 2`: 이전 열의 오른쪽에서 이동한 경우.

`dp[i][j][k]`는 `(i, j)` 위치에 도달할 때, **이전 행의 k 방향(좌, 중앙, 우)에서 이동**한 경우의 최소 비용을 저장합니다.

#### DP 배열 초기화:
```python
dp = [[[float('inf')] * 3 for _ in range(m)] for _ in range(n)]
```
- **`float('inf')`**: 각 셀의 초기값을 무한대(`inf`)로 설정하여 아직 방문하지 않은 경로임을 나타냅니다.
- **`3차원 배열`**: 각 셀에는 왼쪽, 중앙, 오른쪽 3가지 방향에서 도착할 때의 비용을 저장하기 위해 크기 3인 배열을 만듭니다.
- 이 배열의 크기는 `n x m x 3`으로, `n`행과 `m`열에 대해 각 방향에 대한 정보를 저장합니다.

#### 예시:
만약 `n = 4`, `m = 3`일 경우, `dp` 배열은 다음과 같이 초기화됩니다.

```python
dp = [
    [[inf, inf, inf], [inf, inf, inf], [inf, inf, inf]],  # 0번째 행
    [[inf, inf, inf], [inf, inf, inf], [inf, inf, inf]],  # 1번째 행
    [[inf, inf, inf], [inf, inf, inf], [inf, inf, inf]],  # 2번째 행
    [[inf, inf, inf], [inf, inf, inf], [inf, inf, inf]]   # 3번째 행
]
```


### 참고
- 시간 복잡도: `O(n * m)` (각 행에 대해 각 열을 탐색하므로).
- 공간 복잡도: `O(n * m * 3)` (DP 배열을 3차원으로 사용).

### 개선 가능성
- 이 코드는 각 방향에 대한 최소 비용을 모두 기록하여 문제를 해결합니다. 이를 좀 더 간결하게 구현할 수 있지만, 코드의 가독성을 위해 3차원 배열을 사용하여 명시적으로 각 경우를 다루었습니다.

--- 