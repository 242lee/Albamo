# 백준

## 문제
계단은 한 번에 1칸 또는 2칸을 오를 수 있다.
세 개의 연속된 계단을 밟을 수 없다. (즉, 한 번에 3칸을 연속으로 밟는 것은 불가능합니다)
마지막 계단은 반드시 밟아야 한다.
각 계단에는 점수가 부여되어 있으며, 이 점수의 합이 최대가 되도록 해야 합니다. 
문제의 핵심은,  동적 계획법(DP)을 이용해 각 계단에서 얻을 수 있는 최대 점수를 기록해 나가면서 문제를 푸는 것입니다.

## 코드

```python
"""
6
10
20
15
25
10
20
"""

n = int(input())  # 계단의 개수 입력
stairs = [int(input()) for _ in range(n)]  # 각 계단의 점수 입력

# DP 테이블 초기화
dp = [0] * n

# 초기값 설정
dp[0] = stairs[0]  # 첫 번째 계단의 최대 점수는 그 계단의 점수와 동일
if n > 1:
    dp[1] = stairs[0] + stairs[1]  # 두 번째 계단은 첫 번째와 두 번째 계단 점수의 합
if n > 2:
    dp[2] = max(stairs[0] + stairs[2], stairs[1] + stairs[2])  # 세 번째 계단은 첫 번째 + 세 번째 또는 두 번째 + 세 번째 중 큰 값

# DP 점화식을 사용하여 최대 점수 계산
for i in range(3, n):
    dp[i] = max(dp[i-2] + stairs[i], dp[i-3] + stairs[i-1] + stairs[i])

# 마지막 계단까지의 최대 점수 출력
print(dp[-1])
```


### 로직 설명: `dp[0]`, `dp[1]`, `dp[2]` 설정과 점화식 계산 과정

#### 1. 초기값 설정
먼저, `dp[0]`, `dp[1]`, `dp[2]`를 설정합니다. 이 값들은 첫 번째, 두 번째, 세 번째 계단까지 도달하는 데 필요한 최대 점수를 각각 저장합니다.

```python
dp[0] = stairs[0]
if n > 1:
    dp[1] = stairs[0] + stairs[1]
if n > 2:
    dp[2] = max(stairs[0] + stairs[2], stairs[1] + stairs[2])
```

이 부분에서 각 `dp` 값을 어떻게 설정하는지 단계별로 설명하겠습니다.

- **`dp[0]`**:
  - 첫 번째 계단의 최대 점수는 그 계단의 점수와 동일합니다. 
  - 따라서, `dp[0] = stairs[0]`로 설정합니다.
  
- **`dp[1]`**:
  - 첫 번째 계단을 밟고, 두 번째 계단을 밟는 것이 유일한 방법입니다.
  - 따라서, 두 번째 계단까지의 최대 점수는 `dp[1] = stairs[0] + stairs[1]`이 됩니다.

- **`dp[2]`**:
  - 세 번째 계단에 도달하는 방법은 두 가지가 있습니다:
    1. 첫 번째 계단을 밟고, 두 번째 계단을 건너뛰고, 세 번째 계단으로 가는 방법 (`stairs[0] + stairs[2]`).
    2. 두 번째 계단을 밟고, 세 번째 계단을 밟는 방법 (`stairs[1] + stairs[2]`).
  - 이 두 가지 방법 중 더 큰 점수를 선택합니다.
  - 따라서, `dp[2] = max(stairs[0] + stairs[2], stairs[1] + stairs[2])`로 설정됩니다.

이로써 초기값 `dp[0]`, `dp[1]`, `dp[2]`이 설정되었습니다.

#### 2. 점화식을 통한 계산
이제 `dp[3]`부터 `dp[n-1]`까지의 값을 점화식을 이용해 계산합니다.

```python
for i in range(3, n):
    dp[i] = max(dp[i-2] + stairs[i], dp[i-3] + stairs[i-1] + stairs[i])
```

이 반복문은 각 `i`에 대해 두 가지 경우를 고려하여 `dp[i]`를 결정합니다.

- **`dp[i-2] + stairs[i]`**:
  - `i-2`번째 계단에서 한 번에 두 칸을 올라 `i`번째 계단으로 가는 경우입니다.
  - 이 경우의 점수는 `dp[i-2]` (i-2번째 계단까지의 최대 점수)와 `stairs[i]` (i번째 계단의 점수)를 더한 값입니다.

- **`dp[i-3] + stairs[i-1] + stairs[i]`**:
  - `i-3`번째 계단에서 두 칸을 올라 `i-1`번째 계단을 밟고, 다시 한 칸 더 올라 `i`번째 계단으로 가는 경우입니다.
  - 이 경우의 점수는 `dp[i-3]` (i-3번째 계단까지의 최대 점수)와 `stairs[i-1] + stairs[i]` (i-1번째와 i번째 계단의 점수)를 더한 값입니다.

이 두 가지 경우 중 더 큰 값을 선택하여 `dp[i]`에 저장합니다.

### 예시를 통한 이해

예를 들어, 계단 점수가 [10, 20, 15, 25, 10, 20]인 경우를 생각해보겠습니다.

- **초기값 설정**:
  - `dp[0] = 10` (첫 번째 계단 점수)
  - `dp[1] = 10 + 20 = 30` (첫 번째 + 두 번째 계단 점수)
  - `dp[2] = max(10 + 15, 20 + 15) = max(25, 35) = 35` (첫 번째 + 세 번째 또는 두 번째 + 세 번째 계단 점수)

- **점화식 적용**:
  - `dp[3] = max(dp[1] + 25, dp[0] + 15 + 25) = max(30 + 25, 10 + 15 + 25) = max(55, 50) = 55`
  - `dp[4] = max(dp[2] + 10, dp[1] + 25 + 10) = max(35 + 10, 30 + 25 + 10) = max(45, 65) = 65`
  - `dp[5] = max(dp[3] + 20, dp[2] + 10 + 20) = max(55 + 20, 35 + 10 + 20) = max(75, 65) = 75`

마지막 계단까지 계산된 값 중 가장 큰 값이 `dp[5] = 75`가 되며, 이 값이 최종적으로 우리가 찾는 답이 됩니다.

### 결론
이 로직은 계단을 오르는 모든 경우를 고려하여 가장 높은 점수를 계산할 수 있게 해줍니다. 초기값을 설정하고, 각 계단에 대해 두 가지 가능한 경로 중 최적의 경로를 선택하여 `dp` 배열을 채워나가는 방식으로 최종 답을 도출합니다.