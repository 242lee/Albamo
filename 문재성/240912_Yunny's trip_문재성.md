# 31885
## 방법1
주어진 코드의 아이디어는 다음과 같습니다.

1. **아이템을 최대 2번까지 사용할 수 있는 경우를 나누어 처리**:
   - 아이템을 0번 사용할 경우: 원점에서 목적지까지의 맨해튼 거리가 5 이하라면 기력을 충분히 남기고 도착할 수 있습니다.
   - 아이템을 1번 사용할 경우: 한 번의 아이템 사용 후, 목적지까지 거리가 3 이하라면 도착 가능합니다.
   - 아이템을 2번 사용할 경우: 두 번의 아이템 사용이 필요하며, 첫 번째 아이템 사용 후 그 위치에서 목적지로 이동 가능한 아이템이 있는지를 확인합니다.

2. **Set 자료구조 사용**: 특정 좌표에 대한 빠른 탐색을 위해 set을 사용하여 아이템을 관리합니다.

### Python 변환 코드
```python
import sys
from math import inf

# 맨해튼 거리 계산 함수
def manhattan_distance(a, b):
    return abs(a[0] - b[0]) + abs(a[1] - b[1])

def solve():
    # 입력 처리
    input = sys.stdin.readline
    n, k = map(int, input().split())  # 아이템 개수와 초기 기력 입력
    items = set()  # 아이템 저장할 set
    for _ in range(n):
        a, b = map(int, input().split())
        items.add((a, b))  # 아이템을 set에 추가
    Ex, Ey = map(int, input().split())  # 목적지 좌표 입력
    dest = (Ex, Ey)

    ans = k + 1  # 가능한 최대 기력 소모보다 큰 초기값 설정

    # 아이템을 사용하지 않고 목적지까지 가는 경우
    ans = min(ans, manhattan_distance((0, 0), dest))

    # 아이템을 한 번 사용하는 경우
    for item in items:
        sp = 2 + manhattan_distance(item, dest)
        ans = min(ans, sp)

        # 아이템을 두 번 사용하는 경우
        temp = (dest[0] - item[0], dest[1] - item[1])
        if temp in items:
            ans = min(ans, 4)

        # 두 번째 아이템 사용 시 인접한 격자에서 이동 가능 여부 확인
        for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            adj_temp = (temp[0] + dx, temp[1] + dy)
            if adj_temp in items:
                ans = min(ans, 5)

    # 결과 출력
    print(-1 if ans > k else ans)

# 문제 해결 함수 실행
solve()
```

### 코드 설명
1. **입력 처리**:
   - `n, k`: 아이템의 개수와 초기 기력을 입력받습니다.
   - `items`: 아이템을 좌표로 표현한 튜플을 `set`에 저장합니다. 이는 중복된 아이템 없이 빠른 탐색을 가능하게 합니다.
   - `Ex, Ey`: 목적지 좌표를 입력받아 `dest`로 저장합니다.

2. **아이템 사용하지 않는 경우**:
   - 아이템을 사용하지 않고 목적지까지 가는 최단 경로는 맨해튼 거리입니다. 따라서 `manhattan_distance((0, 0), dest)` 값을 계산하고, 이를 초기값과 비교하여 최소값을 유지합니다.

3. **아이템을 1번 사용하는 경우**:
   - 각 아이템을 사용하여 도착할 수 있는 경로를 계산하고, 이때의 기력 소모량을 비교하여 최소값을 업데이트합니다.

4. **아이템을 2번 사용하는 경우**:
   - 첫 번째 아이템을 사용한 후, 두 번째 아이템을 사용할 수 있는지를 탐색합니다. `temp`로 첫 번째 아이템 사용 후 좌표를 계산하고, 두 번째 아이템이 해당 좌표에 존재하는지 확인합니다.
   - 또한, 두 번째 아이템 사용 후 인접한 격자에서 이동할 수 있는 아이템이 있는지 확인합니다.

5. **결과 출력**:
   - 만약 계산된 최소 기력 소모량이 초기 기력 `k`보다 크다면 도착할 수 없으므로 `-1`을 출력하고, 그렇지 않으면 최소 기력 소모량을 출력합니다.

### 성능 최적화
- 이 코드는 모든 아이템을 두 번까지 사용하는 시나리오를 다룹니다.
- 아이템을 저장하고 탐색할 때 `set`을 사용하므로, 좌표 탐색이 `O(1)`로 이루어져 시간 복잡도를 최소화합니다.

## 방법2
### 전체 알고리즘 설명

1. **초기 거리 계산**:
   - `(0, 0)`에서 목적지 `(goal_x, goal_y)`까지 **아이템을 사용하지 않고** 맨해튼 거리로 이동하는 경우를 `res`에 저장합니다. 이 값은 인접한 칸으로만 이동할 때의 최단 거리로, 가장 기본적인 경우입니다.

2. **아이템을 활용한 좌표 계산**:
   - 각 아이템이 `(x, y)` 좌표를 가진다면, 그 아이템을 사용하여 목적지로 갈 수 있는지 확인하기 위해 `(goal_x - x, goal_y - y)`를 계산하고, 이를 `res_set`이라는 집합에 추가합니다. 이 값은 아이템 사용 후 목적지와의 상대적인 좌표 차이를 의미합니다.

3. **아이템 사용과 최소 기력 소모 계산**:
   - 각 아이템을 사용하여 `(goal_x, goal_y)`로 이동할 경우의 기력 소모량을 계산합니다. 이때 아이템 사용 시 기력 2가 소모되며, 남은 거리를 맨해튼 거리로 계산한 후 최소값을 갱신합니다.

4. **두 아이템 사용의 경우**:
   - 아이템을 두 번 사용할 수 있는 경우도 고려합니다. 한 번 아이템을 사용한 후, 다시 아이템을 사용하여 목적지에 도달할 수 있는지를 `res_set`에서 확인하여 기력 소모를 최소화합니다.
   - 만약 두 아이템을 연속으로 사용하여 목적지에 도달할 수 있다면, 최소 기력 소모는 4가 됩니다.

5. **인접한 칸으로 이동하는 경우**:
   - 아이템 사용 후 목적지에 인접한 칸으로 이동할 수 있는 경우도 고려합니다. 즉, 두 번의 아이템 사용 후 한 칸 인접 이동하여 도착할 수 있다면 기력 소모는 5가 됩니다.

6. **최종 기력 소모량 출력**:
   - 계산된 최소 기력 소모량이 초기 기력 `k` 이내라면 그 값을 출력하고, 그렇지 않으면 `-1`을 출력하여 도달할 수 없음을 나타냅니다.

### 주석 달린 주요 부분

1. `res_set.add((goal_x - x, goal_y - y))`: 아이템 사용 후 목표 지점까지의 상대적 위치를 집합에 추가하여 이후 계산에 활용합니다.

2. `res = min(res, abs(goal_x - x) + abs(goal_y - y) + 2)`: 아이템을 사용하여 이동한 경우를 고려한 최소 기력 계산.

3. `if (x, y) in res_set: res = min(res, 4)`: 두 아이템을 연속으로 사용한 경우를 고려한 최소 기력 계산.

4. `for dx, dy in [(1, 0), (0, 1), (-1, 0), (0, -1)]:`: 아이템 사용 후 인접 칸으로 이동하여 목적지에 도달할 수 있는 경우를 계산.

### 코드 분석 및 알고리즘 설명

```python
import sys
input = sys.stdin.readline

# 입력 처리: 아이템 개수 n과 초기 기력 k
n, k = map(int, input().split())

# 아이템 좌표 리스트: n개의 아이템의 (x, y) 좌표를 리스트로 저장
items = [tuple(map(int, input().split())) for _ in range(n)]

# 목적지 좌표 입력: (goal_x, goal_y)
goal_x, goal_y = map(int, input().split())

# 초기값: 목적지까지 아이템을 사용하지 않고 직접 이동하는 경우의 맨해튼 거리
res = abs(goal_x) + abs(goal_y)

# 목적지와 각 아이템 좌표의 상대 좌표를 저장할 set
res_set = set()

# 아이템을 이용해서 목적지까지의 상대 좌표를 set에 추가
for x, y in items:
    res_set.add((goal_x - x, goal_y - y))

# 아이템을 사용하여 이동할 경우와 인접 이동을 고려한 최소 기력 소모 계산
for x, y in items:
    # 아이템을 사용하여 이동 후 목적지까지의 거리 + 아이템 사용시 소모 기력 (2)
    res = min(res, abs(goal_x - x) + abs(goal_y - y) + 2)

    # 만약 아이템을 사용하고 나서 다시 아이템을 사용해 도착할 수 있는지 확인
    if (x, y) in res_set:
        res = min(res, 4)  # 두 아이템을 연속으로 사용하여 도착 가능하면 기력 4 소모

    # 아이템 사용 후 목적지 근처에서 인접한 칸으로 이동하는 경우
    for dx, dy in [(1, 0), (0, 1), (-1, 0), (0, -1)]:
        if (x + dx, y + dy) in res_set:
            res = min(res, 5)  # 두 아이템 사용 후 인접 이동으로 도착 가능하면 기력 5 소모

# 최종적으로 구한 최소 기력 소모가 초기 기력 k 이하인지 확인
print(res if res <= k else -1)
```
