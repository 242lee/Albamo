# 백준 N번째 큰 수

## 문제

N번째 큰 수를 찾는 프로그램을 작성하시오. 표에 채워진 수는 모두 다르다.

입력
첫째 줄에 N(1 ≤ N ≤ 1,500)이 주어진다. 다음 N개의 줄에는 각 줄마다 N개의 수가 주어진다. 
표에 적힌 수는 -10억보다 크거나 같고, 10억보다 작거나 같은 정수이다.

출력
첫째 줄에 N번째 큰 수를 출력한다.

### 메모리 초과 코드

```python
"""
5
12 7 9 15 5
13 8 11 19 6
21 10 26 31 16
48 14 28 35 25
52 20 32 41 49

35
"""

n = int(input())
num_list = [list(map(int, input().split())) for _ in range(n)]

# 2차원 리스트를 1차원 리스트로 변환
flat_list = [num for row in num_list for num in row]
flat_list.sort(reverse=True)
print(flat_list[n-1])
```
#### 문제 개요
- N * N 크기의 행렬에서 **N번째로 큰 수**를 찾는 문제.
- 입력이 매우 크기 때문에, 모든 값을 한 번에 메모리에 로드하고 정렬하는 방식은 **메모리 초과**를 유발할 수 있음.

#### 문제 발생 원인
- 모든 데이터를 메모리에 저장한 후 정렬하면 **메모리 사용량**이 과도하게 증가하게 됨.

#### 해결 방법
- 모든 데이터를 메모리에 저장하지 않고, **heapq 모듈**의 **최소 힙**을 이용해 문제를 해결할 수 있음.
- 최소 힙의 크기를 **N**으로 유지하면서, 힙에 새로운 숫자를 삽입하고, 힙의 크기가 N을 초과할 경우 최솟값을 제거하는 방식을 사용.

#### 핵심 아이디어
1. **heapq 모듈 사용**:
   - heapq는 파이썬 내장 모듈로, 최소 힙을 쉽게 구현할 수 있음.
2. **메모리 사용량 절감**:
   - 정렬 대신 필요한 데이터만 힙에 저장하여 메모리 사용을 최소화.
3. **N번째로 큰 수**:
   - 마지막에 힙의 최솟값이 N번째로 큰 수가 됨.


메모리 초과가 발생하는 이유는 문제에서 요구하는 입력 크기와 메모리 사용량 때문입니다. 백준 2075번 문제는 `N*N` 크기의 행렬에서 `N`번째로 큰 수를 찾는 문제입니다. 입력이 매우 크기 때문에, 모든 값을 한 번에 메모리에 로드하고 정렬하는 방식은 메모리 초과를 유발할 수 있습니다.

이를 해결하기 위해, 모든 데이터를 메모리에 저장하지 않고도 문제를 해결할 수 있는 방법을 사용해야 합니다. `heapq` 모듈의 최소 힙을 이용하여 `N`번째로 큰 수를 찾는 방법을 사용하면 메모리 사용을 줄일 수 있습니다.

### 최소 힙을 이용한 해결 방법
최소 힙을 이용하면 `N*N`개의 숫자 중에서 `N`번째로 큰 숫자를 효율적으로 찾을 수 있습니다. 최소 힙의 크기를 `N`으로 유지하면서, 힙에 새로운 숫자를 삽입하고, 힙의 크기가 `N`을 초과할 경우 최솟값을 제거하는 방식으로 진행합니다.

아래는 수정된 코드입니다:

```python
import heapq

n = int(input())
min_heap = []

for _ in range(n):
    row = list(map(int, input().split()))
    for num in row:
        if len(min_heap) < n:
            heapq.heappush(min_heap, num)
        else:
            if num > min_heap[0]:
                heapq.heappushpop(min_heap, num)

print(min_heap[0])
```

### 코드 설명

1. **`heapq` 모듈 사용**:
   - `heapq`는 Python의 내장 모듈로, 최소 힙을 구현할 수 있게 도와줍니다.
   - `heappush(heap, item)`은 힙에 새로운 아이템을 추가합니다.
   - `heappushpop(heap, item)`은 새로운 아이템을 힙에 추가하고, 힙에서 가장 작은 요소를 제거한 후 반환합니다.

2. **`min_heap` 초기화**:
   - `min_heap`은 최소 힙으로 사용할 빈 리스트입니다.

3. **입력과 처리**:
   - `row` 단위로 숫자를 입력받고, 각 숫자에 대해 처리합니다.
   - `min_heap`의 크기가 `n`보다 작다면, 해당 숫자를 힙에 추가합니다.
   - `min_heap`의 크기가 `n` 이상이면, 현재 숫자가 힙의 최솟값보다 클 경우에만 힙에 추가하고 최솟값을 제거합니다.

4. **결과 출력**:
   - 마지막으로 힙의 최솟값을 출력합니다. 이것이 `N`번째로 큰 수가 됩니다.

### 결론
이 방법을 사용하면 메모리 사용을 최소화하면서도 효율적으로 `N`번째로 큰 수를 찾을 수 있습니다. 전체 데이터를 정렬하는 대신, 
필요한 데이터만 힙에 저장하고 처리하기 때문에 메모리 초과 문제를 해결할 수 있습니다.


# heapq와 deque의 개념과 차이점

## 1. heapq

### 개념
- **heapq**는 파이썬 내장 모듈로, 이진 힙(binary heap) 알고리즘을 사용하여 우선순위 큐(priority queue)를 구현한 것.
- 기본적으로 **최소 힙(min-heap)**으로 작동하며, 가장 작은 요소가 항상 루트에 위치.
- **최대 힙(max-heap)**을 구현하려면, 삽입할 값에 음수 부호를 붙여 사용.

### 주요 함수
- `heapq.heappush(heap, item)`: 힙에 새로운 요소를 추가.
- `heapq.heappop(heap)`: 힙에서 가장 작은 요소를 제거하고 반환.
- `heapq.heappushpop(heap, item)`: 새로운 요소를 힙에 추가한 후, 최솟값을 제거하고 반환.
- `heapq.heapify(iterable)`: 기존 리스트를 힙 구조로 변환.

### 특징
- 힙 정렬(heap sort)과 관련된 효율적인 연산을 수행.
- 힙의 삽입과 삭제 연산은 **O(log n)**의 시간 복잡도를 가짐.
- **작업 스케줄링**이나 **우선순위 기반 작업 처리** 등에 유용.

## 2. deque

### 개념
- **deque**는 **double-ended queue**의 약자로, 양쪽 끝에서 요소의 삽입과 제거가 모두 가능한 자료구조.
- 파이썬의 **collections** 모듈에서 제공되며, 큐와 스택의 기능을 모두 지원.

### 주요 함수
- `deque.append(item)`: 요소를 덱의 오른쪽 끝에 추가.
- `deque.appendleft(item)`: 요소를 덱의 왼쪽 끝에 추가.
- `deque.pop()`: 덱의 오른쪽 끝에서 요소를 제거하고 반환.
- `deque.popleft()`: 덱의 왼쪽 끝에서 요소를 제거하고 반환.
- `deque.extend(iterable)`: 반복 가능한 객체의 모든 요소를 덱의 오른쪽 끝에 추가.
- `deque.extendleft(iterable)`: 반복 가능한 객체의 모든 요소를 덱의 왼쪽 끝에 추가.

### 특징
- 양쪽 끝에서 **O(1)** 시간 복잡도로 삽입과 삭제가 가능.
- **스택**(Last-In-First-Out)과 **큐**(First-In-First-Out) 작업 모두를 효율적으로 처리.
- 회전(`rotate`) 기능을 통해 덱을 효율적으로 순환할 수 있음.

## 3. heapq와 deque의 차이점

| 특징                | heapq                                           | deque                          |
|---------------------|-------------------------------------------------|--------------------------------|
| 기본 구조           | 이진 힙 (최소 힙)                               | 양방향 큐 (double-ended queue) |
| 삽입/삭제 시간 복잡도 | O(log n)                                        | O(1)                           |
| 주요 기능           | 우선순위 큐, 힙 정렬                            | 큐와 스택 기능 모두 지원        |
| 주요 사용 사례      | 작업 스케줄링, 우선순위 기반 작업 처리           | BFS, 회전, 양방향 큐           |
| 데이터 접근 방식    | 최솟값/최댓값 우선 접근                           | 양쪽 끝에서 삽입/삭제          |

### 결론
- **heapq**는 **우선순위가 중요한 작업**에 적합하며, 데이터의 최솟값 또는 최댓값에 빠르게 접근할 수 있음.
- **deque**는 **양방향에서 삽입과 삭제가 자주 발생**하는 경우에 효율적이며, **큐**와 **스택**의 기능을 모두 제공.
