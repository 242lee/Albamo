'''
문제 설명
양의 정수 x에 대한 함수 f(x)를 다음과 같이 정의합니다.

x보다 크고 x와 비트가 1~2개 다른 수들 중에서 제일 작은 수
예를 들어,

f(2) = 3 입니다. 다음 표와 같이 2보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 3이기 때문입니다.
수	비트	다른 비트의 개수
2	000...0010	
3	000...0011	1
f(7) = 11 입니다. 다음 표와 같이 7보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 11이기 때문입니다.
수	비트	다른 비트의 개수
7	000...0111	
8	000...1000	4
9	000...1001	3
10	000...1010	3
11	000...1011	2
정수들이 담긴 배열 numbers가 매개변수로 주어집니다. numbers의 모든 수들에 대하여 각 수의 f 값을 배열에 차례대로 담아 return 하도록 solution 함수를 완성해주세요.

제한사항
1 ≤ numbers의 길이 ≤ 100,000
0 ≤ numbers의 모든 수 ≤ 1015
입출력 예
numbers	result
[2,7]	[3,11]
'''
# 풀이
# 1. 짝수일 때
# e.g) 2 = 0010 -> 첫번째 비트가 0이면(짝수이면) 1을 더하면 된다.
# 2. 홀수일 때
# e.g) 15 = 1111 -> 비트를 바꾸는 순간 숫자가 작아진다.
# e.g) 9 = 1001 -> 1010   2번째 비트를 바꾸면 최솟값 10가 된다.
# e.g) 19 = 10011 -> 10101  21

# 수가 짝수일 때면, 1을 더해주면 되고,
# 수가 홀수일 때,
# 2^n - 1에 해당하는 숫자면, 2^n + 2^(n-1) - 1 이 된다.
# 1111   -> 10111    111 -> 1000  - 1
# 나머지 숫자이면, 첫번째 비트부터 순회하면서 0인 비트를 만나면 1로 바꾸고 그 오른쪽 비트를 0으로 바꾼 뒤 break한다. 

def solution(numbers):
    answer = []
    
    for num in numbers:
        if num % 2 == 0:
            answer.append(num + 1)  # 짝수일 경우 1을 더하면 답이 됨
        else:
            bin_num = bin(num)[2:]  # 이진수 문자열로 변환
            length = len(bin_num)
            
            # 모든 비트가 1인지 확인
            if all(bit == '1' for bit in bin_num):
                answer.append((1 << length) + (1 << (length - 1)) - 1)
            else:
                # num에서 첫 번째로 0인 비트를 찾아 1로 변경하고, 그 아래 비트는 최소화
                for i in range(length - 1, -1, -1):
                    if bin_num[i] == '0':  # 가장 오른쪽에 있는 0을 찾음
                        new_num = num + (1 << (length - 1 - i))  # 해당 비트를 1로 변경
                        new_num -= (1 << (length - 2 - i))  # 그 바로 오른쪽 비트를 0으로 변경
                        answer.append(new_num)
                        break
    
    return answer

# 테스트 케이스 실행

print(solution([19, 7]))