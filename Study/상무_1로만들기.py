# 처음 생각한 방법.
# 문제에서 주어진 숫자에서 3이 나눠질 때까지 1을 뺀다.
# 해당 방법은 기각. 예외처리 할 것이 너무 많다.

# 두번째 방법. 2의 제곱과 3의 제곱의 곱으로 이루어진 숫자중 문제에서 주어진 숫자와 가장 근접한 숫자를 구해본다.
# 기각.

# 세번째 방법.
# 각 자리의 숫자의 합을 3으로 나눈 나머지가 2이면 2로 나누던가 -1후 2로 나눈다.
# 각 자리의 숫자의 합을 3으로 나눈 나머지가 1이고, 4의 배수이면 2로 두번 나눈다. 3으로 나눈 나머지가 1이고 4의배수가 아니면 1을 뺀 후 3으로 나눈다.
# 나머지는 3으로 나눈다.

# 네번째 방법.

import sys
input = sys.stdin.readline

N = int(input())

dp = [[0, []] for _ in range(N + 1)]   # 최솟값, 계산 과정을 넣어 줄 리스트
dp[1][0] = 0
dp[1][1] = [1]  # 계산의 마지막은 1이다.

# 2 ~ N 까지 순서대로 최소 경로를 채운다.
for i in range(2, N + 1):

    # dp[i]에 닿는 경우는 3가지다. dp[i-1], dp[i//3], dp[i//2]에서 1을 더해주거나 3을 곱해주거나 2를 곱해주는 경우.
    # 그래서 3가지 경우를 비교해서 dp[i]에 가장 최솟값을 저장해준다.

    # dp[i-1]에서 1 더해주는 경우
    dp[i][0] = dp[i-1][0] + 1
    dp[i][1] = dp[i-1][1] + [i]

    # dp[i//3]에서 3 곱해주는 경우   
    if i % 3 == 0 and dp[i//3][0] + 1 < dp[i][0]:
        dp[i][0] = dp[i//3][0] + 1
        dp[i][1] = dp[i//3][1] + [i]

    # dp[i//3]에서 3 곱해주는 경우   
    if i % 2 == 0 and dp[i//2][0] + 1 < min(dp[i][0],dp[i//3][0] + 1):
        dp[i][0] = dp[i//2][0] + 1
        dp[i][1] = dp[i//2][1] + [i]

print(dp[N][0])

for i in dp[N][1][::-1]:
    print(i, end=' ')