
# 비트 연산과 시프트 연산 - 백준 15787번 문제 풀이

이 문서는 비트 연산, 시프트 연산의 개념과 이를 백준 15787번 문제에서 어떻게 활용하는지에 대한 설명을 제공합니다.

## 1. 비트 연산

비트 연산은 숫자를 이진수로 변환하여 개별 비트를 조작하는 연산입니다. 주요 비트 연산 종류는 다음과 같습니다:

- **AND (`&`)**: 대응하는 비트가 둘 다 1일 때만 결과가 1.
- **OR (`|`)**: 대응하는 비트 중 하나라도 1이면 결과가 1.
- **XOR (`^`)**: 대응하는 비트가 다를 때 결과가 1.
- **NOT (`~`)**: 모든 비트를 반전시킵니다 (0은 1로, 1은 0으로).
- **왼쪽 시프트 (`<<`)**: 비트를 왼쪽으로 이동시키고 오른쪽을 0으로 채웁니다.
- **오른쪽 시프트 (`>>`)**: 비트를 오른쪽으로 이동시키고 왼쪽을 0으로 채웁니다.

### 비트 연산 예시

`x = 5` (이진수로 `101`)일 때:

```python
x & 3  # 101 & 011 = 001 (1)
x | 3  # 101 | 011 = 111 (7)
x ^ 3  # 101 ^ 011 = 110 (6)
~x     # ~101 = 010 (2)
```

## 2. 시프트 연산

### 왼쪽 시프트 (`<<`)
왼쪽 시프트는 비트를 왼쪽으로 이동시키고 오른쪽에 0을 채웁니다. 이는 2의 거듭제곱으로 곱하는 효과가 있습니다. 예를 들어:

```python
x = 5  # 이진수: 101
x << 1  # 이진수: 1010, 결과: 10 (5 * 2^1)
x << 2  # 이진수: 10100, 결과: 20 (5 * 2^2)
```

### 오른쪽 시프트 (`>>`)
오른쪽 시프트는 비트를 오른쪽으로 이동시키고 왼쪽에 0을 채웁니다. 이는 2로 나누는 효과가 있습니다:

```python
x = 20  # 이진수: 10100
x >> 1  # 이진수: 1010, 결과: 10 (20 // 2^1)
x >> 2  # 이진수: 101, 결과: 5 (20 // 2^2)
```

## 3. 비트 연산과 시프트 연산을 백준 15787번에서 활용하기

이 문제에서는 기차의 좌석 상태(20개의 좌석)를 비트마스크로 관리합니다. 각 기차는 20비트의 이진수로 좌석 상태를 표현하고, 이를 비트 연산을 통해 효율적으로 처리합니다.

### 비트 연산과 시프트 연산을 사용하는 이유

- **메모리 절약**: 20개의 좌석을 배열로 관리하는 대신, 하나의 20비트 정수로 관리합니다.
- **빠른 연산**: 배열을 조작하는 것보다 비트 연산이 훨씬 빠릅니다.

### 3.1. 명령어 처리 방법

1. **1 i x**: i번째 기차의 x번째 좌석에 사람을 태웁니다.
    - 코드: `trains[i] |= (1 << (x - 1))`
    - **OR 연산**을 사용하여 x번째 좌석을 1로 설정합니다.
  
2. **2 i x**: i번째 기차의 x번째 좌석에서 사람을 내립니다.
    - 코드: `trains[i] &= ~(1 << (x - 1))`
    - **AND**와 **NOT 연산**을 사용하여 x번째 좌석을 0으로 설정합니다.

3. **3 i**: i번째 기차의 좌석을 한 칸 뒤로 이동시키고, 20번째 좌석은 비워둡니다.
    - 코드: `trains[i] = (trains[i] << 1) & ((1 << 20) - 1)`
    - **왼쪽 시프트**를 사용하여 좌석을 한 칸 뒤로 밀고, 20비트를 넘지 않도록 마스크를 적용합니다.

4. **4 i**: i번째 기차의 좌석을 한 칸 앞으로 이동시키고, 1번째 좌석은 비워둡니다.
    - 코드: `trains[i] >>= 1`
    - **오른쪽 시프트**를 사용하여 좌석을 한 칸 앞으로 이동시킵니다.

### 3.2. 중복 기차 상태 처리

모든 명령어가 끝난 후, 기차 상태의 중복을 제거하기 위해 `set`을 사용합니다:

```python
unique_trains = set(trains)
print(len(unique_trains))  # 중복을 제거한 고유한 기차 상태의 개수를 출력합니다.
```

### 3.3. 전체 코드 예시

```python
n, m = map(int, input().split())
trains = [0] * n  # 기차의 좌석 상태를 비트마스크로 관리

for _ in range(m):
    command = list(map(int, input().split()))
    if command[0] == 1:
        trains[command[1] - 1] |= (1 << (command[2] - 1))
    elif command[0] == 2:
        trains[command[1] - 1] &= ~(1 << (command[2] - 1))
    elif command[0] == 3:
        trains[command[1] - 1] = (trains[command[1] - 1] << 1) & ((1 << 20) - 1)
    elif command[0] == 4:
        trains[command[1] - 1] >>= 1

# 중복된 기차 상태 제거
unique_trains = set(trains)
print(len(unique_trains))  # 고유한 기차 상태 개수 출력
```

## 결론

비트 연산과 시프트 연산을 활용하면 백준 15787번과 같은 문제를 매우 효율적으로 해결할 수 있습니다. 이 연산들을 사용함으로써 메모리 사용량을 줄이고 성능을 크게 향상시킬 수 있습니다.
